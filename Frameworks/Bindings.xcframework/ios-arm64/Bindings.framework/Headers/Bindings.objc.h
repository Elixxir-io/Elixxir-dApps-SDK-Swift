// Objective-C API for talking to gitlab.com/elixxir/client/bindings Go package.
//   gobind -lang=objc gitlab.com/elixxir/client/bindings
//
// File is generated by gobind. Do not edit.

#ifndef __Bindings_H__
#define __Bindings_H__

@import Foundation;
#include "ref.h"
#include "Universe.objc.h"


@class BindingsAuthenticatedConnection;
@class BindingsClient;
@class BindingsConnection;
@class BindingsE2ESendReport;
@class BindingsFact;
@class BindingsIdentity;
@class BindingsMessage;
@class BindingsRestlikeMessage;
@class BindingsRoundsList;
@protocol BindingsClientError;
@class BindingsClientError;
@protocol BindingsListener;
@class BindingsListener;
@protocol BindingsLogWriter;
@class BindingsLogWriter;
@protocol BindingsMessageDeliveryCallback;
@class BindingsMessageDeliveryCallback;
@protocol BindingsNetworkHealthCallback;
@class BindingsNetworkHealthCallback;

@protocol BindingsClientError <NSObject>
- (void)report:(NSString* _Nullable)source message:(NSString* _Nullable)message trace:(NSString* _Nullable)trace;
@end

@protocol BindingsListener <NSObject>
/**
 * Hear is called to receive a message in the UI
Accepts a marshalled Message object
 */
- (void)hear:(NSData* _Nullable)item;
/**
 * Name returns a name, used for debugging
 */
- (NSString* _Nonnull)name;
@end

@protocol BindingsLogWriter <NSObject>
- (void)log:(NSString* _Nullable)p0;
@end

@protocol BindingsMessageDeliveryCallback <NSObject>
- (void)eventCallback:(BOOL)delivered timedOut:(BOOL)timedOut roundResults:(NSData* _Nullable)roundResults;
@end

@protocol BindingsNetworkHealthCallback <NSObject>
- (void)callback:(BOOL)p0;
@end

@interface BindingsAuthenticatedConnection : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped field AuthenticatedConnection.Connection with unsupported type: gitlab.com/elixxir/client/bindings.Connection

- (void)close;
- (long)getId;
- (NSData* _Nullable)getPartner;
- (BOOL)isAuthenticated;
- (void)registerListener:(long)messageType newListener:(id<BindingsListener> _Nullable)newListener;
- (NSData* _Nullable)sendE2E:(long)mt payload:(NSData* _Nullable)payload error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * Client BindingsClient wraps the api.Client, implementing additional functions
to support the gomobile Client interface
 */
@interface BindingsClient : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * Connect performs auth key negotiation with the given recipient,
and returns a Connection object for the newly-created partner.Manager
This function is to be used sender-side and will block until the
partner.Manager is confirmed.
recipientContact - marshalled contact.Contact object
myIdentity - marshalled Identity object
 */
- (BindingsConnection* _Nullable)connect:(NSData* _Nullable)recipientContact myIdentity:(NSData* _Nullable)myIdentity error:(NSError* _Nullable* _Nullable)error;
- (BindingsAuthenticatedConnection* _Nullable)connectWithAuthentication:(NSData* _Nullable)recipientContact myIdentity:(NSData* _Nullable)myIdentity error:(NSError* _Nullable* _Nullable)error;
/**
 * GetContactFromIdentity accepts a marshalled Identity object and returns a marshalled contact.Contact object
 */
- (NSData* _Nullable)getContactFromIdentity:(NSData* _Nullable)identity error:(NSError* _Nullable* _Nullable)error;
- (long)getID;
/**
 * HasRunningProcessies checks if any background threads are running.
returns true if none are running. This is meant to be
used when NetworkFollowerStatus() returns Stopping.
Due to the handling of comms on iOS, where the OS can
block indefiently, it may not enter the stopped
state apropreatly. This can be used instead.
 */
- (BOOL)hasRunningProcessies;
/**
 * IsNetworkHealthy returns true if the network is read to be in a healthy state where
messages can be sent
 */
- (BOOL)isNetworkHealthy;
/**
 * MakeIdentity generates a new cryptographic identity for receiving messages
 */
- (NSData* _Nullable)makeIdentity:(NSError* _Nullable* _Nullable)error;
/**
 * Gets the state of the network follower. Returns:
Stopped 	- 0
Starting - 1000
Running	- 2000
Stopping	- 3000
 */
- (long)networkFollowerStatus;
/**
 * RegisterClientErrorCallback registers the callback to handle errors from the
long running threads controlled by StartNetworkFollower and StopNetworkFollower
 */
- (void)registerClientErrorCallback:(id<BindingsClientError> _Nullable)clientError;
/**
 * RegisterNetworkHealthCB registers the network health callback to be called
any time the network health changes. Returns a unique ID that can be used to
unregister the network health callback.
 */
- (int64_t)registerNetworkHealthCB:(id<BindingsNetworkHealthCallback> _Nullable)nhc;
/**
 * StartNetworkFollower kicks off the tracking of the network. It starts
long running network client threads and returns an object for checking
state and stopping those threads.
Call this when returning from sleep and close when going back to
sleep.
These threads may become a significant drain on battery when offline, ensure
they are stopped if there is no internet access
Threads Started:
  - Network Follower (/network/follow.go)
  	tracks the network events and hands them off to workers for handling
  - Historical Round Retrieval (/network/rounds/historical.go)
		Retrieves data about rounds which are too old to be stored by the client
	 - Message Retrieval Worker Group (/network/rounds/retrieve.go)
		Requests all messages in a given round from the gateway of the last nodes
	 - Message Handling Worker Group (/network/message/handle.go)
		Decrypts and partitions messages when signals via the Switchboard
	 - health Tracker (/network/health)
		Via the network instance tracks the state of the network
	 - Garbled Messages (/network/message/garbled.go)
		Can be signaled to check all recent messages which could be be decoded
		Uses a message store on disk for persistence
	 - Critical Messages (/network/message/critical.go)
		Ensures all protocol layer mandatory messages are sent
		Uses a message store on disk for persistence
	 - KeyExchange Trigger (/keyExchange/trigger.go)
		Responds to sent rekeys and executes them
  - KeyExchange Confirm (/keyExchange/confirm.go)
		Responds to confirmations of successful rekey operations
 */
- (BOOL)startNetworkFollower:(long)timeoutMS error:(NSError* _Nullable* _Nullable)error;
/**
 * StopNetworkFollower stops the network follower if it is running.
It returns errors if the Follower is in the wrong status to stop or if it
fails to stop it.
if the network follower is running and this fails, the client object will
most likely be in an unrecoverable state and need to be trashed.
 */
- (BOOL)stopNetworkFollower:(NSError* _Nullable* _Nullable)error;
- (void)unregisterNetworkHealthCB:(int64_t)funcID;
/**
 * WaitForMessageDelivery allows the caller to get notified if the rounds a
message was sent in successfully completed. Under the hood, this uses an API
which uses the internal round data, network historical round lookup, and
waiting on network events to determine what has (or will) occur.

The callbacks will return at timeoutMS if no state update occurs

This function takes the marshaled send report to ensure a memory leak does
not occur as a result of both sides of the bindings holding a reference to
the same pointer.
 */
- (BOOL)waitForMessageDelivery:(NSData* _Nullable)roundList mdc:(id<BindingsMessageDeliveryCallback> _Nullable)mdc timeoutMS:(long)timeoutMS error:(NSError* _Nullable* _Nullable)error;
/**
 * WaitForNewtwork will block until either the network is healthy or the
passed timeout. It will return true if the network is healthy
 */
- (BOOL)waitForNetwork:(long)timeoutMS;
@end

/**
 * Connection is the bindings representation of a connect.Connection object that can be tracked by id
 */
@interface BindingsConnection : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * Close deletes this Connection's partner.Manager and releases resources
 */
- (void)close;
/**
 * GetId returns the Connection.id
 */
- (long)getId;
/**
 * GetPartner returns the partner.Manager for this Connection
 */
- (NSData* _Nullable)getPartner;
/**
 * RegisterListener is used for E2E reception
and allows for reading data sent from the partner.Manager
Returns marshalled ListenerID
 */
- (void)registerListener:(long)messageType newListener:(id<BindingsListener> _Nullable)newListener;
/**
 * SendE2E is a wrapper for sending specifically to the Connection's partner.Manager
Returns marshalled E2ESendReport
 */
- (NSData* _Nullable)sendE2E:(long)mt payload:(NSData* _Nullable)payload error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * E2ESendReport is the bindings representation of the return values of SendE2E
Example E2ESendReport:
{"Rounds":[1,5,9],
 "MessageID":"51Yy47uZbP0o2Y9B/kkreDLTB6opUol3M3mYiY2dcdQ=",
 "Timestamp":1653582683183384000}
 */
@interface BindingsE2ESendReport : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped field E2ESendReport.RoundsList with unsupported type: gitlab.com/elixxir/client/bindings.RoundsList

@property (nonatomic) NSData* _Nullable messageID;
@property (nonatomic) int64_t timestamp;
- (NSData* _Nullable)marshal:(NSError* _Nullable* _Nullable)error;
@end

/**
 * Fact is an internal fact type for use in the bindings layer
example marshalled Fact:
{"Fact":"Zezima","Type":0}
 */
@interface BindingsFact : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@property (nonatomic) NSString* _Nonnull fact;
@property (nonatomic) long type;
@end

/**
 * Identity struct
Example marshalled Identity:
{"ID":"emV6aW1hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD",  // User ID (base64)
 // RSA Private key (PEM format)
 "RSAPrivatePem":"LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcFFJQkFBS0NBUUVBNU15dTdhYjBJOS9UL1BFUUxtd2x3ejZHV3FjMUNYemVIVXhoVEc4bmg1WWRWSXMxCmJ2THpBVjNOMDJxdXN6K2s4TVFEWjBtejMzdkswUmhPczZIY0NUSFdzTEpXRkE5WWpzWWlCRi9qTDd1bmd1ckIKL2tvK1JJSnNrWGFWaEZaazRGdERoRXhTNWY4RnR0Qmk1NmNLZmdJQlVKT3ozZi9qQllTMkxzMlJ6cWV5YXM3SApjV2RaME9TclBTT3BiYlViU1FPbS9LWnlweGZHU21yZ2oxRUZuU1dZZ2xGZTdUOTRPbHF5MG14QTV5clVXbHorCk9sK3hHbXpCNUp4WUFSMU9oMFQrQTk4RWMrTUZHNm43L1MraDdzRDgybGRnVnJmbStFTzRCdmFKeTRESGZGMWgKNnp6QnVnY25NUVFGc0dLeDFYWC9COTVMdUpPVjdyeXlDbzZGbHdJREFRQUJBb0lCQVFDaUh6OGNlcDZvQk9RTAphUzBVRitHeU5VMnlVcVRNTWtTWThoUkh1c09CMmFheXoybHZVb3RLUHBPbjZRSWRWVTJrcE4vY2dtY0lSb2x5CkhBMDRUOHJBWVNaRlVqaVlRajkzKzRFREpJYXd2Z0YyVEs1bFoyb3oxVTdreStncU82V0RMR2Z0Q0wvODVQWEIKa210aXhnUXpRV3g1RWcvemtHdm03eURBalQxeDloNytsRjJwNFlBam5kT2xTS0dmQjFZeTR1RXBQd0kwc1lWdgpKQWc0MEFxbllZUmt4emJPbmQxWGNjdEJFN2Z1VDdrWXhoeSs3WXYrUTJwVy9BYmh6NGlHOEY1MW9GMGZwV0czCmlISDhsVXZFTkp2SUZEVHZ0UEpESlFZalBRN3lUbGlGZUdrMXZUQkcyQkpQNExzVzhpbDZOeUFuRktaY1hOQ24KeHVCendiSlJBb0dCQVBUK0dGTVJGRHRHZVl6NmwzZmg3UjJ0MlhrMysvUmpvR3BDUWREWDhYNERqR1pVd1RGVQpOS2tQTTNjS29ia2RBYlBDb3FpL0tOOVBibk9QVlZ3R3JkSE9vSnNibFVHYmJGamFTUzJQMFZnNUVhTC9rT2dUCmxMMUdoVFpIUWk1VUlMM0p4M1Z3T0ZRQ3RQOU1UQlQ0UEQvcEFLbDg3VTJXN3JTY1dGV1ZGbFNkQW9HQkFPOFUKVmhHWkRpVGFKTWVtSGZIdVYrNmtzaUlsam9aUVVzeGpmTGNMZ2NjV2RmTHBqS0ZWTzJNN3NqcEJEZ0w4NmFnegorVk14ZkQzZ1l0SmNWN01aMVcwNlZ6TlNVTHh3a1dRY1hXUWdDaXc5elpyYlhCUmZRNUVjMFBlblVoWWVwVzF5CkpkTC8rSlpQeDJxSzVrQytiWU5EdmxlNWdpcjlDSGVzTlR5enVyckRBb0dCQUl0cTJnN1RaazhCSVFUUVNrZ24Kb3BkRUtzRW4wZExXcXlBdENtVTlyaWpHL2l2eHlXczMveXZDQWNpWm5VVEp0QUZISHVlbXVTeXplQ2g5QmRkegoyWkRPNUdqQVBxVHlQS3NudFlNZkY4UDczZ1NES1VSWWVFbHFDejdET0c5QzRzcitPK3FoN1B3cCtqUmFoK1ZiCkNuWllNMDlBVDQ3YStJYUJmbWRkaXpLbEFvR0JBSmo1dkRDNmJIQnNISWlhNUNJL1RZaG5YWXUzMkVCYytQM0sKMHF3VThzOCtzZTNpUHBla2Y4RjVHd3RuUU4zc2tsMk1GQWFGYldmeVFZazBpUEVTb0p1cGJzNXA1enNNRkJ1bwpncUZrVnQ0RUZhRDJweTVwM2tQbDJsZjhlZXVwWkZScGE0WmRQdVIrMjZ4eWYrNEJhdlZJeld3NFNPL1V4Q3crCnhqbTNEczRkQW9HQWREL0VOa1BjU004c1BCM3JSWW9MQ2twcUV2U0MzbVZSbjNJd3c1WFAwcDRRVndhRmR1ckMKYUhtSE1EekNrNEUvb0haQVhFdGZ2S2tRaUI4MXVYM2c1aVo4amdYUVhXUHRteTVIcVVhcWJYUTlENkxWc3B0egpKL3R4SWJLMXp5c1o2bk9IY1VoUUwyVVF6SlBBRThZNDdjYzVzTThEN3kwZjJ0QURTQUZNMmN3PQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQ==",
 // Salt for identity (base64)
 "Salt":"4kk02v0NIcGtlobZ/xkxqWz8uH/ams/gjvQm14QT0dI=",
 // DH Private key
 "DHKeyPrivate":"eyJWYWx1ZSI6NDU2MDgzOTEzMjA0OTIyODA5Njg2MDI3MzQ0MzM3OTA0MzAyODYwMjM2NDk2NDM5NDI4NTcxMTMwNDMzOTQwMzgyMTIyMjY4OTQzNTMyMjIyMzc1MTkzNTEzMjU4MjA4MDA0NTczMDY4MjEwNzg2NDI5NjA1MjA0OTA3MjI2ODI5OTc3NTczMDkxODY0NTY3NDExMDExNjQxNCwiRmluZ2VycHJpbnQiOjE2ODAxNTQxNTExMjMzMDk4MzYzfQ=="
}
 */
@interface BindingsIdentity : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@property (nonatomic) NSData* _Nullable id_;
@property (nonatomic) NSData* _Nullable rsaPrivatePem;
@property (nonatomic) NSData* _Nullable salt;
@property (nonatomic) NSData* _Nullable dhKeyPrivate;
@end

/**
 * Message is the bindings representation of a receive.Message
Example Message format:
{"MessageType":1,
 "ID":"EB/70R5HYEw5htZ4Hg9ondrn3+cAc/lH2G0mjQMja3w=",
 "Payload":"7TzZKgNphT5UooNM7mDSwtVcIs8AIu4vMKm4ld6GSR8YX5GrHirixUBAejmsgdroRJyo06TkIVef7UM9FN8YfQ==",
 "Sender":"emV6aW1hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD",
 "RecipientID":"amFrZXh4MzYwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD",
 "EphemeralID":17,"Timestamp":1653580439357351000,
 "Encrypted":false,
 "RoundId":19}
 */
@interface BindingsMessage : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@property (nonatomic) long messageType;
@property (nonatomic) NSData* _Nullable id_;
@property (nonatomic) NSData* _Nullable payload;
@property (nonatomic) NSData* _Nullable sender;
@property (nonatomic) NSData* _Nullable recipientID;
@property (nonatomic) int64_t ephemeralID;
@property (nonatomic) int64_t timestamp;
@property (nonatomic) BOOL encrypted;
@property (nonatomic) long roundId;
@end

/**
 * RestlikeMessage is the bindings representation of a restlike.Message
Example marshalled RestlikeMessage:
{"Version":1,
"Headers":"Y29udGVudHM6YXBwbGljYXRpb24vanNvbg==",
"Content":"VGhpcyBpcyBhIHJlc3RsaWtlIG1lc3NhZ2U=",
"Method":2,
"URI":"xx://CmixRestlike/rest",
"Error":""}
 */
@interface BindingsRestlikeMessage : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped field RestlikeMessage.Version with unsupported type: uint32

@property (nonatomic) NSData* _Nullable headers;
@property (nonatomic) NSData* _Nullable content;
@property (nonatomic) long method;
@property (nonatomic) NSString* _Nonnull uri;
@property (nonatomic) NSString* _Nonnull error;
@end

/**
 * Example marshalled roundList object:
[1001,1003,1006]
 */
@interface BindingsRoundsList : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped field RoundsList.Rounds with unsupported type: []int

- (NSData* _Nullable)marshal:(NSError* _Nullable* _Nullable)error;
@end

/**
 * DownloadAndVerifySignedNdfWithUrl retrieves the NDF from a specified URL.
The NDF is processed into a protobuf containing a signature which
is verified using the cert string passed in. The NDF is returned as marshaled
byte data which may be used to start a client.
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsDownloadAndVerifySignedNdfWithUrl(NSString* _Nullable url, NSString* _Nullable cert, NSError* _Nullable* _Nullable error);

/**
 * EnableGrpcLogs sets GRPC trace logging
 */
FOUNDATION_EXPORT void BindingsEnableGrpcLogs(id<BindingsLogWriter> _Nullable writer);

/**
 * GenerateSecret creates a secret password using a system-based
pseudorandom number generator. It takes 1 parameter, `numBytes`,
which should be set to 32, but can be set higher in certain cases.
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsGenerateSecret(long numBytes);

/**
 * GetDependencies returns the api DEPENDENCIES
 */
FOUNDATION_EXPORT NSString* _Nonnull BindingsGetDependencies(void);

/**
 * GetFactsFromContact accepts a marshalled contact.Contact object, returning its marshalled list of Fact objects
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsGetFactsFromContact(NSData* _Nullable marshaled, NSError* _Nullable* _Nullable error);

/**
 * GetGitVersion rturns the api GITVERSION
 */
FOUNDATION_EXPORT NSString* _Nonnull BindingsGetGitVersion(void);

/**
 * GetIDFromContact accepts a marshalled contact.Contact object & returns a marshalled id.ID object
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsGetIDFromContact(NSData* _Nullable marshaled, NSError* _Nullable* _Nullable error);

/**
 * GetPubkeyFromContact accepts a marshalled contact.Contact object & returns a json marshalled large.Int DhPubKey
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsGetPubkeyFromContact(NSData* _Nullable marshaled, NSError* _Nullable* _Nullable error);

/**
 * GetVersion returns the api SEMVER
 */
FOUNDATION_EXPORT NSString* _Nonnull BindingsGetVersion(void);

/**
 * sets level of logging. All logs the set level and above will be displayed
options are:
	TRACE		- 0
	DEBUG		- 1
	INFO 		- 2
	WARN		- 3
	ERROR		- 4
	CRITICAL	- 5
	FATAL		- 6
The default state without updates is: INFO
 */
FOUNDATION_EXPORT BOOL BindingsLogLevel(long level, NSError* _Nullable* _Nullable error);

/**
 * Login will load an existing client from the storageDir
using the password. This will fail if the client doesn't exist or
the password is incorrect.
The password is passed as a byte array so that it can be cleared from
memory and stored as securely as possible using the memguard library.
Login does not block on network connection, and instead loads and
starts subprocesses to perform network operations.
TODO: add in custom parameters instead of the default
 */
FOUNDATION_EXPORT BindingsClient* _Nullable BindingsLogin(NSString* _Nullable storageDir, NSData* _Nullable password, NSError* _Nullable* _Nullable error);

/**
 * NewClient creates client storage, generates keys, connects, and registers
with the network. Note that this does not register a username/identity, but
merely creates a new cryptographic identity for adding such information
at a later date.

Users of this function should delete the storage directory on error.
 */
FOUNDATION_EXPORT BOOL BindingsNewClient(NSString* _Nullable network, NSString* _Nullable storageDir, NSData* _Nullable password, NSString* _Nullable regCode, NSError* _Nullable* _Nullable error);

/**
 * RegisterLogWriter registers a callback on which logs are written.
 */
FOUNDATION_EXPORT void BindingsRegisterLogWriter(id<BindingsLogWriter> _Nullable writer);

/**
 * RestlikeRequest performs a normal restlike request
request - marshalled RestlikeMessage
Returns marshalled result RestlikeMessage
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsRestlikeRequest(long clientID, long connectionID, NSData* _Nullable request, NSError* _Nullable* _Nullable error);

/**
 * RestlikeRequestAuth performs an authenticated restlike request
request - marshalled RestlikeMessage
Returns marshalled result RestlikeMessage
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsRestlikeRequestAuth(long clientID, long authConnectionID, NSData* _Nullable request, NSError* _Nullable* _Nullable error);

/**
 * SetFactsOnContact replaces the facts on the contact with the passed in facts
pass in empty facts in order to clear the facts
Accepts a marshalled contact.Contact object & a marshalled list of Fact objects
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsSetFactsOnContact(NSData* _Nullable marshaled, NSData* _Nullable facts, NSError* _Nullable* _Nullable error);

@class BindingsClientError;

@class BindingsListener;

@class BindingsLogWriter;

@class BindingsMessageDeliveryCallback;

@class BindingsNetworkHealthCallback;

@interface BindingsClientError : NSObject <goSeqRefInterface, BindingsClientError> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)report:(NSString* _Nullable)source message:(NSString* _Nullable)message trace:(NSString* _Nullable)trace;
@end

/**
 * Listener provides a callback to hear a message
An object implementing this interface can be called back when the client
gets a message of the type that the registerer specified at registration
time.
 */
@interface BindingsListener : NSObject <goSeqRefInterface, BindingsListener> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * Hear is called to receive a message in the UI
Accepts a marshalled Message object
 */
- (void)hear:(NSData* _Nullable)item;
/**
 * Name returns a name, used for debugging
 */
- (NSString* _Nonnull)name;
@end

@interface BindingsLogWriter : NSObject <goSeqRefInterface, BindingsLogWriter> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)log:(NSString* _Nullable)p0;
@end

/**
 * MessageDeliveryCallback gets called on the determination if all events
related to a message send were successful.
If delivered == true, timedOut == false && roundResults != nil
If delivered == false, roundResults == nil
If timedOut == true, delivered == false && roundResults == nil
 */
@interface BindingsMessageDeliveryCallback : NSObject <goSeqRefInterface, BindingsMessageDeliveryCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)eventCallback:(BOOL)delivered timedOut:(BOOL)timedOut roundResults:(NSData* _Nullable)roundResults;
@end

/**
 * A callback when which is used to receive notification if network health
changes
 */
@interface BindingsNetworkHealthCallback : NSObject <goSeqRefInterface, BindingsNetworkHealthCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)callback:(BOOL)p0;
@end

#endif
